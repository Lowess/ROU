#    rou
#    an airplug compatible program
#    author: Bertrand Ducourthial AT utc.fr, Anthony Buisset (v0.1)
#    license type: free of charge license for academic and research purpose
#    see license.txt
### MODULE RECEPTION ##########################################################

### VARIABLES DU MODULE #######################################################
# dernier message recu
set ROU_rcv_msg $APG_msg_unknown

# application emettrice du dernier message (en cas d'option --whatwho)
set ROU_rcv_app $APG_msg_unknown

# mnemonique pour le header ROU, contenant le nom de l'application qui a emis
# le message transporte.
set ROU_rcv_mnemoapp $ROU_rc_mnemoapp

###############################################################################


### ZONE DU MODULE ############################################################
## zone du module reception
labelframe .rcv -pady 2 -padx 2 \
    -text "Réception \[$APP, ident = $APG_ident\]"  -fg $APG_int_coltitle

label .rcv.t1 -text "Dernier message reçu de "
label .rcv.app -textvariable ROU_rcv_app -width 4 -fg $APG_int_colmsgrcv
label .rcv.t2 -text " : "
label .rcv.msg -textvariable ROU_rcv_msg -width 64  -fg $APG_int_colmsgrcv -anchor w
pack .rcv.t1 .rcv.app .rcv.t2 .rcv.msg -side left -fill y -pady 2

# affichage des sous-zones de la zone rcv
pack .rcv.msg .rcv.app -side left -fill y -pady 2
###############################################################################


### OPTIONS DE LA LIGNE DE COMMANDE ###########################################
foreach option $APG_lstargs {
    set name [lindex [split $option "="] 0]
    set value [lindex [split $option "="] 1]
    
    switch -- $name {
				--source {
						#--------------------------------------------------------------------------------
						# applications emettrices auxquelles il faut s'abonner
						#--------------------------------------------------------------------------------
						if { $value == "" } {
								APG_vrb_dispwarning "option $name trouvee sans argument ; ignoree"
						} else {
								APG_vrb_dispnotif "option $option trouvee, abonnement a l'app source $value"
								APG_begin_lch $value
						}
				}
    }
}
###############################################################################

### PROCEDURES DU MODULE ######################################################


# Procedure to unserialize the route table
proc ROU_unserialize { paramChaine_a_deSerialiser } {

	set res [split $paramChaine_a_deSerialiser ","]
	return $res

}

#-- Procedure APG_receive_whatwho --------------------------------------------#
# Action : gere la reception de messages                                      #
# Remarq : surcharge de LIBAPGTK                                              #
# Entree : payload et emetteur                                                #
# Retour : rien                                                               #
#-----------------------------------------------------------------------------#
proc APG_receive_whatwho { what who } {

		# Mise a jour de l'interface du module rcv.
    set ::ROU_rcv_msg $what
    set ::ROU_rcv_app $who

		# Traitement different selon l'emetteur.
    switch -- $::ROU_rcv_app \
				$::APP {

						# Récuperation of the receiver and the payload
						set app [APG_msg_splitstr who $::ROU_rcv_mnemoapp]
						set msg [APG_msg_endstr what $::ROU_rcv_mnemoapp true]
						#APG_vrb_dispdebug "MSG Test node $::APP $::ROU_rcv_msg $msg"
						set typemsg [APG_msg_splitstr what $::ROU_rc_mnemoTypeMessage]
						set tableroutage [APG_msg_splitstr what $::ROU_rc_mnemoTableRoutage]

						#ROU_tab_displayRoutingTable $::ROU_tab_routingTable
						
						APG_vrb_dispdebug "test $typemsg"
						# if it's only 2 app ROU who exchange theirs tables
						if { $typemsg == "routage" } {
							set table_routage_recu [ROU_unserialize $tableroutage]
							# we try to update the existing route (or create some new one)
							ROU_tab_displayRoutingTable $table_routage_recu								

###### POUR FLO : C'est la que je remarque que ca fait pas tout a fait ce que je pense le setRoute. 

							ROU_tab_setRoute $table_routage_recu

							ROU_tab_displayRoutingTable $::ROU_tab_routingTable

							#set test [ROU_tab_getRoute 

						# else , it's will be some package to transfert to an other 
						# node
						#} else { 


##### Pour Flo : la c'est dans le cas ou il s'agit d'un message d'une appli a une autre (autre que de l'echange de table de routage donc)
							if { $typemsg == "OTHER" } {
								# we extract the destination of the packet
								set destapp [APG_msg_splitstr what $::ROU_rc_mnemoDestApp]
								set destnode [APG_msg_splitstr what $::ROU_rc_mnemoDestNode]
								# if the destination is the current node.
								if { $destnode == $::APP } {

##### Pour FLO : J'ai virer les send pour le moment (broadcast storm) mais qui se reglera si on trouve une solution a notre probleme.


									APG_vrb_dispdebug "On est sur le bon node $::APP" 	
									#we send the packet to the correct local application
									#ENVOYER packet
									#ROU_snd_send $msg $::APP

								# else, we send it to an other location.
								} else {

									APG_vrb_dispdebug "On est pas sur le bon node $::APP dest $destnode"
									#set nextHopeApp [ROU_getRout $dest]
									#ROU_snd_send $msg $::APP

								}
							}
						#}
				} \

#### A SUPP
				default {
						APG_vrb_dispdebug "On est pas sur le bon node test $::APP "
						# if it's come from a local application
						# we set the who, with the current app, and send the message
						set header [APG_msg_createmsg $::ROU_rcv_mnemoapp $who]
						set msg [APG_msg_concatemsg $header $what]
						#ROU_snd_send $msg $::APP
				}
}

